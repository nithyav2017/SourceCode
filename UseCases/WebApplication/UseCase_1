Usecase: .NET MVC site slows on user profiles. Implement OutputCache in controllers, invalidate on SQL updates with triggers, and  use distributed Redis.

This is Caching Strategies for Dynamic Pages: Below is the practical implementation to address this performance issue on UserProfile
pages.

# Implement OutputCaching in Controller:
In this example I have used the DataBase `AdventureWorks2022 `.

Use [OutputCache] attribute to actions that render user profiles to cache the complete HTML response. 

```  [HttpGet("{id}")]
        [ResponseCache(Duration = 600, VaryByQueryKeys = new[] {"id"}, Location = ResponseCacheLocation.Any)]
        public async Task<IActionResult> Index(int id)
        {
            var cacheKey = $"Profile_{id}";
            if (!_cache.TryGetValue(cacheKey, out var profile))
            {
                Console.WriteLine("Fetching profile {id} from DB at {DateTime.Now}");
                profile = await _userService.GetProfileDTO(id);

                if(profile !=null)
                {
                    _cache.Set(cacheKey, profile, TimeSpan.FromMinutes(10));
                }
            }

            return Ok(profile);
        }```

This will cache the profile data for 10 minutes on server and reduce the DB hit.  In .NET , “VaryByQuerKeys” is  “VaryByParam”.

Use Distributed Caching across Servers:

The classic  [OutputCache] attribute caches data in-memory. To share cached data across servers  , 
	-	Configure Redis as the output cache provider in the appsettings.json /Web.Config.

To integrate Redis in the application
	-	Microsoft.Extensions.Caching.StackExchangeRedis - [it Let use  Redis as a distributed cache provider]
	- StackExchange.Redis [ it connects redis to the local Redis server or azure redis]

Appsettings.json Configuration:
`"ConnectionStrings": {
   "Redis": "localhost:6379",
   "AdventureWorks": "Server=localhost,1433;Database=AdventureWorks2022;User Id=sa;Password=******;TrustServerCertificate=true"
 }`

# Program.cs:

# Configure distributed cache service if the cache has to be shared across servers. 
`builder.Services.AddStackExchangeRedisCache(options =>
{
    options.Configuration = builder.Configuration.GetConnectionString("Redis");
    options.InstanceName = "SampleInstance";
}); `

# Manage Redis Connection
To get the address and port for the Redis server to which the app will connect.

var redisConnection = builder.Configuration.GetConnectionString("Redis"); 

# ConnectionMultiplexer 
	- The Redis connection is managed by ConnectionMultiplexer, which should be registered as a singleton. Both the application’s 
    Redis cache implementation  and any background services (e.g., subscribers listening for cache update messages) must share 
    the same ConnectionMultiplexer instance.
	`builder.Services.AddSingleton<IConnectionMultiplexer>(sp => ConnectionMultiplexer.Connect(redisConnection!));`

# Invlidate Cache on SQL update:
# Option 1: 
# step 1:
# Register a Backgroundservice to listen cache update message 
	-In the UseCase example project, I have created `CacheInvalidationSubscriber` , it receives cache updates  through channel on 
	 subscriber . 
	- It starts autmatically when the application launches.
	- It connects to Redis through `IConnectionMultiplexer `
	- It subscribes to the channel `Cache-Invalidate`
  - When a message is received, it removes the relevant entry from `IMemoryCache`

		`builder.Services.AddHostedService<CacheInvalidationSubscriber>();`

	[ref: https://github.com/nithyav2017/SourceCode/blob/Dotnet/UseCases/WebApplication/CodeSample/WebApplication/Services/Redis/RedisBackgroundService/CacheInvalidationSubscriber.cs]

#Step 2:
	Send message to Redis through a channel called 'Profile-Invalidate' , any Redis clients like backgroundservices that has subscribed
to "Profile-Invalidate" will immediately receive message and IMemoryCache/IDistributedCache removed it from  `_memoryCache.Remove($"Profile_{userId}")`
# Use In-MemoryCache To Cache in a single server :

# Add In-Process Cache(In-MemoryCache) - if the caching has to be done in one server
		- Adding  `builder.Services.AddMemoryCache();` registers an inprocess cache that stores data in the memory of the current application
		- Here I tested with InMemoryCache.
instance.

#Option 2:
#SQL Trigger + External Notification (For external DB changes):
	- Create SQL trigger on the Person.Person table to insert new row into a `ChangeLog` table .
	- Use a background service for example Quartz.NET or Azure Function to monitor `ChangeLog` and publish to Redis


	 
 










